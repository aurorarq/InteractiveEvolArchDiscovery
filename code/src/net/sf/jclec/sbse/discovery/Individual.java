package net.sf.jclec.sbse.discovery;

import org.apache.commons.lang.builder.EqualsBuilder;

import net.sf.jclec.IFitness;
import net.sf.jclec.IIndividual;
import net.sf.jclec.mo.IConstrained;
import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.SyntaxTreeIndividual;
import net.sf.jclec.syntaxtree.SyntaxTreeNode;

/**
 * Abstract Individual for the discovery problem.
 * It represents a component-based architectural model, storing
 * the genotype and general properties of the solution. Subclasses
 * will implement specific properties of the problem formulation
 * (ranking-based, multi-objective...)
 * 
 * @author Aurora Ramirez Quesada
 * @author Jose Raul Romero
 * @author Sebastian Ventura
 * 
 * @version 3.0
 * History:
 * <ul>
 * 	<li>1.0: Creation (January 2013)
 * 	<li>2.0: Refactoring. New properties: rankings, difSize, constraints properties. (July 2013)
 *  <li>2.1: Added methods: equals, isEquivalent, constraintViolation. (November 2013)
 *  <li>3.0: Removing ranking and specific metric properties. New class hierarchy. (December 2013)
 * </ul>
 * */

public class Individual extends SyntaxTreeIndividual implements IConstrained{

	//////////////////////////////////////////////////////////////////
	//----------------------------------------------------- Properties
	//////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	private static final long serialVersionUID = -773562361871564558L;

	/** Individual phenotype */
	private String phenotype = new String();

	/** Number of components */
	private int numberOfComponents;

	/** Number of connectors */
	private int numberOfConnectors;

	///// Properties used in mutator heuristics

	/** Number of classes in each component */
	private int [] numberOfClasses;

	/** Number of groups in each component */
	private int [] numberOfGroups;

	/** Classes distribution */
	private int [] distribution;

	/** Class group in the component */
	private int [] classesToGroups;

	///// Other measures (useful information for listeners and toString() method)

	/** Number of associations in each component */
	private int [] numberOfAssoc;

	/** Number of composition relations in each component */
	private int [] numberOfCompos;

	/** Number of dependence relations in each component */
	private int [] numberOfDepen;

	/** Number of aggregation relations in each component */
	private int [] numberOfAggreg;

	/** Number of inheritance relations in each component */
	private int [] numberOfGener;

	/** Number of connections with other components */
	private int [] numberOfExtConnections;

	/** Number of provided interfaces in each component */
	private int [] numberOfProvided;

	/** Number of required interfaces in each component */
	private int [] numberOfRequired;

	/** Number of abstract classes in each component */
	private int [] numberOfAbstractClasses;

	/** Number of distinct data type references in each component */
	private int [] numberOfDistinctTypes;

	// Constraints

	/** The architecture has, at least, one isolated component */
	private boolean hasIsolated;

	/** The architecture has, at least, a pair of mutually dependent components */
	private boolean hasPairMutuallyDep;

	//////////////////////////////////////////////////////////////////
	//--------------------------------------------------- Constructors
	//////////////////////////////////////////////////////////////////

	/**
	 * Constructor that sets individual genotype
	 * @param genotype: Individual genotype
	 * */
	public Individual(SyntaxTree genotype){
		super(genotype);				// Set genotype
		setPhenotypefromGenotype();		// Set phenotype
		countComponents();				// Set number of components
		countConnectors();				// Set number of connectors
		setInterfacesDistribution();	// Locate provided/required interfaces
		setInterfaceDependencies();		// Locate provided/required dependencies
	}

	/**
	 * Constructor that sets individual genotype and fitness
	 * @param genotype: Individual genotype
	 * @param fitness:  Individual fitness
	 */
	public Individual(SyntaxTree genotype, IFitness fitness) {
		super(genotype,fitness);		// Set genotype and fitness
		setPhenotypefromGenotype();		// Set phenotype
		countComponents();				// Set number of components
		countConnectors();				// Set number of connectors
		setInterfacesDistribution();	// Locate provided/required interfaces
		setInterfaceDependencies();		// Locate provided/required dependencies
	}

	//////////////////////////////////////////////////////////////////
	//----------------------------------------------- Override methods
	//////////////////////////////////////////////////////////////////

	/** 
	 * Copy the individual
	 * @return A copy of the individual
	 * */
	@Override
	public IIndividual copy() {
		// To be refined by the subclasses
		return null;
	}

	@Override
	public String toString(){

		StringBuffer buffer = new StringBuffer();
		buffer.append("\n\n"+this.phenotype);
		buffer.append("\n#components: " + this.numberOfComponents);
		buffer.append("\n#connectors: " + this.numberOfConnectors);

		buffer.append("\nisFeasible?: " + this.isFeasible());

		if(this.fitness != null){
			// Verbose mode
			boolean printRel = !(this.numberOfAssoc == null);
			boolean printExtConn = !(this.numberOfExtConnections == null);

			buffer.append("\nComponents: ");
			for(int i=0; i<this.numberOfComponents; i++){
				buffer.append("\nComponent: " + i + " -- #classes: " + this.numberOfClasses[i]);
				buffer.append("\n\tProvided interfaces: " + this.numberOfProvided[i]);
				buffer.append("\n\tRequired interfaces: " + this.numberOfRequired[i]);

				if(printRel)
					buffer.append("\n\t#assoc: " + this.numberOfAssoc[i] + " -- #depen: " + this.numberOfDepen[i]  +
							" -- #aggreg: " + this.numberOfAggreg[i] + " -- #compos: " + this.numberOfCompos[i] + " --  #gener: " + this.numberOfGener[i]);
				if(printExtConn)
					buffer.append("\n\tExternal connections: " + this.numberOfExtConnections[i]);
			}
		}
		return buffer.toString();
	}

	@Override
	public boolean equals(Object other){	
		// To be refined by subclasses
		return false;
	}

	//////////////////////////////////////////////////////////////////
	//------------------------------------------------- Public methods
	//////////////////////////////////////////////////////////////////

	/**
	 * Get phenotype.
	 * @return The individual phenotype.
	 * */
	public String getPhenotype(){
		return this.phenotype;
	}

	/**
	 * Translate the genotype into a phenotype.
	 * */
	public void setPhenotypefromGenotype(){
		StringBuffer buffer = new StringBuffer();
		int iSize = this.genotype.size();

		buffer.append("\narchitecture: \n");
		for(int i=1; i<iSize; i++){
			SyntaxTreeNode oNode = this.genotype.getNode(i);
			if(oNode.getSymbol().equalsIgnoreCase("components"))
				buffer.append("\t");
			else if(oNode.getSymbol().equalsIgnoreCase("component"))
				buffer.append("\t\t");
			else if(oNode.getSymbol().equalsIgnoreCase("classes"))
				buffer.append("\t\t\t");
			else if(oNode.arity()==0){ 
				if(!oNode.getSymbol().contains(":"))	// Terminal node (class or connector)
					buffer.append("\t\t\t\t");
				else // Terminal node (interface operation)
					buffer.append("\t\t\t\t\t");
			}
			else if(oNode.arity()!=0 && oNode.getSymbol().contains("-interface"))
				buffer.append("\t\t\t");
			else if(oNode.getSymbol().equalsIgnoreCase("interface"))
				buffer.append("\t\t\t\t");
			else if(oNode.getSymbol().equalsIgnoreCase("connectors"))
				buffer.append("\t");
			else if(oNode.getSymbol().equalsIgnoreCase("connector"))
				buffer.append("\t\t");

			buffer.append(oNode.getSymbol() + "\n");

		}
		this.phenotype = new String(buffer.toString());
	}

	/**
	 * Get invalid condition. An individual is invalid
	 * if it has, at least, one isolated component or
	 * it has, at least, a pair of mutually dependent components
	 * 
	 * @return True if individual is invalid, false otherwise
	 * */
	/*public boolean isInvalid(){
		return (this.hasIsolated || this.hasPairMutuallyDep);
	}*/

	/**
	 * Check if the individual is equivalent to other, i.e
	 * although they have different genotypes, both represent
	 * the same architectural model.
	 * @param other: the other individual
	 * @return True if both individuals are equivalent
	 * */
	public boolean isEquivalent(Individual other){	

		// Check general properties: type of solution and fitness
		EqualsBuilder eb = new EqualsBuilder();
		eb.append(this.numberOfComponents, other.numberOfComponents);
		eb.append(this.numberOfConnectors, other.numberOfConnectors);
		
		if(this.fitness!=null && other.getFitness()!=null){
			eb.append(fitness, other.fitness);
		}
		
		// The two solution could be the same, check if they represent 
		// the same architectural model (not only same genotype)
		if(eb.isEquals()){
			return equivalentClassesDistribution(this.distribution, other.distribution);
		}
		else{
			return false;
		}
	}

	//////////////////////////////////////////////////////////////////
	//-------------------------------- Public getters/setters methods
	//////////////////////////////////////////////////////////////////

	/**
	 * Get the number of components
	 * @return The number of components
	 * */
	public int getNumberOfComponents(){
		return this.numberOfComponents;
	}

	/**
	 * Get the number of components
	 * @param numberOfComponents: The number of components
	 * */
	protected void setNumberOfComponents(int numberOfComponents){
		this.numberOfComponents = numberOfComponents;
	}

	/**
	 * Get the number of connectors
	 * @return The number of connectors
	 * */
	public int getNumberOfConnectors(){
		return this.numberOfConnectors;
	}

	/**
	 * Set the number of connectors
	 * @param numberOfConnectors: The number of connectors
	 * */
	protected void setNumberOfConnectors(int numberOfConnectors){
		this.numberOfConnectors = numberOfConnectors;
	}

	/**
	 * Get number of groups in a given component
	 * @param index The component index
	 * @return The number of groups in the component
	 * */
	public int getNumberOfGroups(int index) {
		return this.numberOfGroups[index];
	}

	/**
	 * Get number of groups in each component
	 * @return The number of groups in each component
	 * */
	protected int [] getNumberOfGroups() {
		return this.numberOfGroups;
	}

	/**
	 * Set number of groups (graph connected components)
	 * in each component.
	 * @param numOfGroups: The array with the number of groups
	 * */
	public void setNumberOfGroups(int [] numOfGroups) {
		int size = numOfGroups.length;
		this.numberOfGroups = new int[size];
		for(int i=0; i<size; i++)
			this.numberOfGroups[i] = numOfGroups[i];
	}

	/**
	 * Get the number of classes in the given component
	 * @param index The component index
	 * @return The number of classes in the component
	 * */
	public int getNumberOfClasses(int index){
		return this.numberOfClasses[index];
	}

	/**
	 * Get the number of classes in each component
	 * @return The number of classes in each component
	 * */
	protected int[] getNumberOfClasses(){
		return this.numberOfClasses;
	}

	/**
	 * Set the number of classes in each component
	 * @param numOfClasses: Array with the number of classes in each component
	 * */
	public void setNumberOfClasses(int [] numOfClasses){
		int size = numOfClasses.length;
		this.numberOfClasses = new int[size];
		for(int i=0; i<size; i++)
			this.numberOfClasses[i] = numOfClasses[i];
	}

	/**
	 * Get the component of a given class
	 * @param index The class index
	 * @return The component containing this class
	 * */
	public int getComponent(int index){
		return this.distribution[index];
	}

	/**
	 * Get the classes distribution
	 * @return classesDistribution: The classes distribution
	 * */
	public int [] getClassesDistribution() {
		return this.distribution;
	}

	/**
	 * Set the classes distribution
	 * @param classesDistribution: The classes distribution
	 * */
	public void setClassesDistribution(int [] classesDistribution) {
		int size = classesDistribution.length;
		this.distribution = new int[size];
		for(int i=0; i<size; i++)
			this.distribution[i] = classesDistribution[i];
	}

	/**
	 * Get the group of a given class
	 * @param index: The class index
	 * @return The group containing this class
	 * */
	public int getGroup(int index){
		return this.classesToGroups[index];
	}

	/**
	 * Get the groups of classes
	 * @return Classes to group distribution
	 * */
	protected int [] getClassesToGroups() {
		return this.classesToGroups;
	}

	/**
	 * Set the groups of classes
	 * @param classesGroups: The groups of classes
	 * */
	public void setClassesToGroups(int [] classesGroups) {
		int size = classesGroups.length;
		this.classesToGroups = new int[size];
		for(int i=0; i<size; i++)
			this.classesToGroups[i] = classesGroups[i];
	}

	/**
	 * Get the number of association between
	 * classes that belong to a specified component.
	 * @param index: The component index
	 * @return The number of associations in the component
	 * */
	public int getAssociations(int index) {
		return this.numberOfAssoc[index];
	}

	/**
	 * Set the number of associations in each component.
	 * @param numAssociations: The array with the number of associations
	 * */
	public void setAssociations(int [] numAssociations){
		int size = numAssociations.length;
		this.numberOfAssoc = new int[size];
		for(int i=0; i<size; i++)
			this.numberOfAssoc[i] = numAssociations[i];
	}

	/**
	 * Get the number of dependences between
	 * classes that belong to a specified component.
	 * @param index: The component index
	 * @return The number of dependences in the component
	 * */
	public int getNumberOfDepen(int index) {
		return this.numberOfDepen[index];
	}

	/**
	 * Set number of dependences in each component.
	 * @param numDependences: The array with the number of dependences
	 * */
	public void setDependences(int [] numDependences){
		int size = numDependences.length;
		this.numberOfDepen = new int[size];
		for(int i=0; i<size; i++)
			this.numberOfDepen[i] = numDependences[i];
	}

	/**
	 * Get the number of aggregations between
	 * classes that belong to a specified component.
	 * @param index: The component index
	 * @return The number of aggregations in the component
	 * */
	public int getNumberOfAggreg(int index) {
		return this.numberOfAggreg[index];
	}

	/**
	 * Set number of aggregations in each component.
	 * @param numAggregations: The array with the number of aggregations
	 * */
	public void setAggregations(int [] numAggregations){
		int size = numAggregations.length;
		this.numberOfAggreg = new int[size];
		for(int i=0; i<size; i++)
			this.numberOfAggreg[i] = numAggregations[i];
	}

	/**
	 * Get the number of compositions between
	 * classes that belong to a specified component.
	 * @param index: The component index
	 * @return The number of compositions in the component
	 * */
	public int getNumberOfCompos(int index) {
		return numberOfCompos[index];
	}

	/**
	 * Set number of composition relations in each component.
	 * @param numCompositions: The array with the number of compositions
	 * */
	public void setCompositions(int [] numCompositions){
		int size = numCompositions.length;
		this.numberOfCompos = new int[size];
		for(int i=0; i<size; i++)
			this.numberOfCompos[i] = numCompositions[i];
	}

	/**
	 * Get the number of generalizations between
	 * classes that belong to a specified component.
	 * @param index: The component index
	 * @return The number of generalizations in the component
	 * */
	public int getNumberOfGener(int index) {
		return numberOfGener[index];
	}

	/**
	 * Set number of generalizations in each component.
	 * @param numGeneralizations: The array with the number of generalizations
	 * */
	public void setGeneralizations(int [] numGeneralizations){
		int size = numGeneralizations.length;
		this.numberOfGener = new int[size];
		for(int i=0; i<size; i++)
			this.numberOfGener[i] = numGeneralizations[i];
	}

	/**
	 * Get the number of external relations in
	 * each component
	 * @return The array with the number of external connections
	 * */
	public int [] getExternalConnections(){
		return this.numberOfExtConnections;
	}

	/**
	 * Set number of external connections in each component.
	 * @param externalConnections: The array with the number of external connections
	 * */
	public void setExternalConnections(int [] externalConnections) {
		int size = externalConnections.length;
		this.numberOfExtConnections = new int[size];
		for(int i=0; i<size; i++)
			this.numberOfExtConnections[i] = externalConnections[i];
	}


	/**
	 * Get the number of provided interfaces
	 * for each component
	 * @return The number of interfaces that each component provides
	 * */
	protected int [] getNumberOfProvided() {
		return numberOfProvided;
	}

	/**
	 * Get the number of provided interfaces
	 * for the specified component
	 * @param index: The component index
	 * @return The number of interfaces that the component provides
	 * */
	public int getNumberOfProvided(int index) {
		return numberOfProvided[index];
	}

	/**
	 * Set the number of provided interfaces
	 * @param numOfProvided: The number of provided interfaces
	 * */
	public void setNumberOfProvided(int [] numOfProvided) {
		int size = numOfProvided.length;
		this.numberOfProvided = new int[size];
		for(int i=0; i<size; i++)
			this.numberOfProvided[i] = numOfProvided[i];
	}

	/**
	 * Get the number of required interfaces
	 * for each component
	 * @return The number of interfaces that each component requires
	 * */
	protected int [] getNumberOfRequired() {
		return numberOfRequired;
	}

	/**
	 * Get the number of required interfaces
	 * for the specified component
	 * @param index: The component index
	 * @return The number of interfaces that the component requires
	 * */
	public int getNumberOfRequired(int index) {
		return numberOfRequired[index];
	}

	/**
	 * Set the number of required interfaces
	 * @param numberOfRequired: The number of required interfaces
	 * */
	public void setNumberOfRequired(int [] numberOfRequired) {
		int size = numberOfRequired.length;
		this.numberOfRequired = new int[size];
		for(int i=0; i<size; i++)
			this.numberOfRequired[i] = numberOfRequired[i];
	}

	/**
	 * Set the number of abstract classes in each component
	 * @param numberOfAbstract Number of abstract classes
	 * */
	public void setNumberOfAbstractClasses(int [] numberOfAbstract) {
		int size = numberOfAbstract.length;
		this.numberOfAbstractClasses = new int[size];
		for(int i=0; i<size; i++)
			this.numberOfAbstractClasses[i] = numberOfAbstract[i];
	}

	/**
	 * Get the number of abstract classes
	 * @return Number of abstract classes per component
	 * */
	public int [] getNumberOfAbstractClasses(){
		return this.numberOfAbstractClasses;
	}

	/**
	 * Set the number of distinct data types per component
	 * @param numberOfDataTypes Number of data types
	 * */
	public void setNumberOfDataTypes(int [] numberOfDataTypes) {
		int size = numberOfDataTypes.length;
		this.numberOfDistinctTypes = new int[size];
		for(int i=0; i<size; i++)
			this.numberOfDistinctTypes[i] = numberOfDataTypes[i];
	}

	/**
	 * Get the number of different data types
	 * in each component
	 * @return Number of data types per component
	 * */
	public int [] getNumberOfDataTypes(){
		return this.numberOfDistinctTypes;
	}

	/**
	 * The solution has isolated component?
	 * @return true/false
	 * */
	public boolean hasIsolatedComponents(){
		return this.hasIsolated;
	}

	/**
	 * Set if the solution has isolated components
	 * @param hasIsolated: New constraint value
	 * */
	protected void setHasIsolatedComponents(boolean hasIsolated){
		this.hasIsolated = hasIsolated;
	}

	/**
	 * The solution has components mutually
	 * dependent?
	 * @return true/false
	 * */
	public boolean hasMutuallyDepComponents(){
		return this.hasPairMutuallyDep;
	}

	/**
	 * Set if the solution has mutually dependent components
	 * @param hasMutually: New constraint value
	 * */
	protected void setHasMutuallyDepComponents(boolean hasMutually){
		this.hasPairMutuallyDep = hasMutually;
	}
	
	/**
	 * {@inheritDoc}
	 * */
	@Override
	public boolean isFeasible() {
		boolean cond1 = hasIsolatedComponents();
		boolean cond2 = hasMutuallyDepComponents();
		return (!cond1 && !cond2);
	}

	/**
	 * {@inheritDoc}
	 * Return the degree of infeasibility. It count
	 * the number of constraints that the individual
	 * violates. 
	 * @return 0 if individual
	 * is valid, 1 if individual violates 1 constraint, 2 if individual
	 * violates both constraints
	 * */
	@Override
	public double degreeOfInfeasibility() {
		boolean cond1 = hasIsolatedComponents();
		boolean cond2 = hasMutuallyDepComponents();
		if (!cond1 && !cond2)
			return 0.0;
		else if (cond1 && cond2)
			return 2.0;
		else
			return 1.0;
	}


	//////////////////////////////////////////////////////////////////
	//------------------------------------------------ Private methods
	//////////////////////////////////////////////////////////////////

	/**
	 * Count the number of components in the architecture
	 * */
	protected void countComponents(){
		this.numberOfComponents=0;
		// Search for component symbols
		int size = this.getGenotype().size();
		for(int i=0; i<size; i++)
			if(this.getGenotype().getNode(i).getSymbol().equalsIgnoreCase("component"))
				this.numberOfComponents++;
	}

	/**
	 * Count the number of connectors in the architecture
	 * */
	protected void countConnectors(){
		this.numberOfConnectors=0;
		// Search for connector symbols
		int size = this.getGenotype().size();
		for(int i=0; i<size; i++)
			if(this.getGenotype().getNode(i).getSymbol().equalsIgnoreCase("connector"))
				this.numberOfConnectors++;
	}

	/**
	 * Count the number of required and provided interfaces
	 * */
	protected void setInterfacesDistribution(){
		int actualCmp=-1;
		boolean isInterface = false, isConnector = false;
		String symbol;

		// Initialize
		int componentNumProvided [] = new int [numberOfComponents];
		int componentNumRequired [] = new int [numberOfComponents];

		// Search interfaces in the components
		for(int i=1; !isConnector; i++){

			symbol = genotype.getNode(i).getSymbol();

			// Non terminal node
			if(genotype.getNode(i).arity()!=0){
				// The symbol classes indicates the beginning of a new component
				if(symbol.equalsIgnoreCase("classes")){
					isInterface=false;
					actualCmp++;
					componentNumRequired[actualCmp] = 0;
					componentNumProvided[actualCmp] = 0;
				}
				else if(symbol.equalsIgnoreCase("required-interfaces")){
					isInterface=true;
				}
				else if(symbol.equalsIgnoreCase("connectors")){
					isConnector=true;
				}
			}
			// Terminal node
			else{
				if (isInterface){ // Interfaces
					// A required interface
					if(symbol.contains("_req_"))
						componentNumRequired[actualCmp]++;
					// A provided interface
					else
						componentNumProvided[actualCmp]++;
				}
			}
		}// end of tree route

		this.setNumberOfProvided(componentNumProvided);
		this.setNumberOfRequired(componentNumRequired);

		// Check constraint
		this.hasIsolated = false;
		for(int i=0; !this.hasIsolated && i<numberOfComponents; i++)
			if(componentNumProvided[i]==0 && componentNumRequired[i]==0)
				this.hasIsolated = true;
	}

	/**
	 * Check if the architectural solution has
	 * mutually dependent components
	 * */
	protected void setInterfaceDependencies(){
		// Get genotype
		int j, actualCmp=-1, otherCmp=-1;
		boolean isInterface = false, isConnector = false;
		String symbol;

		// Initialize
		boolean componentIntefaceConnections [][] = new boolean [numberOfComponents][numberOfComponents];

		for(int i=0; i<numberOfComponents; i++)
			for(j=0; j<numberOfComponents; j++)
				componentIntefaceConnections[i][j] = false;

		// Compute metrics for each component in the individual
		for(int i=1; !isConnector; i++){

			symbol = genotype.getNode(i).getSymbol();
			// Non terminal node
			if(genotype.getNode(i).arity()!=0){

				// The beginning of a new component
				if(symbol.equalsIgnoreCase("component")){
					isInterface=false;
					actualCmp++;
				}
				// The beginning of a new set of interfaces		
				if(symbol.equalsIgnoreCase("required-interfaces")){
					isInterface=true;
				}
				else if(symbol.equalsIgnoreCase("connectors")){
					isConnector=true;
				}
			}
			// Terrminal node
			else{
				if (isInterface){ // Interfaces

					// If it is a required interface, search the component that provides the interface
					if(symbol.contains("_req_")){

						String classNameReq1 = symbol.substring(0, symbol.indexOf("_"));
						String classNameReq2 = symbol.substring(symbol.lastIndexOf("_")+1);

						otherCmp=-1;			
						j=1;		// Start in the first component (second node)
						boolean found=false, isOtherInterface=false;

						while(!found){

							String otherSymbol = genotype.getNode(j).getSymbol();
							if(otherSymbol.equalsIgnoreCase("component")){
								otherCmp++;
								isOtherInterface=false;
							}
							else if(genotype.getNode(j-1).getSymbol().equalsIgnoreCase("provided-interfaces"))
								isOtherInterface=true;

							if(otherCmp!=actualCmp && isOtherInterface){

								String classNameProv1 = otherSymbol.substring(0, otherSymbol.indexOf("_"));
								String classNameProv2 = otherSymbol.substring(otherSymbol.lastIndexOf("_")+1);

								// An interface between components
								if(classNameReq1.equalsIgnoreCase(classNameProv2) 
										&& classNameReq2.equalsIgnoreCase(classNameProv1)){
									componentIntefaceConnections[actualCmp][otherCmp]=true;
									found=true;
								}
							}
							j++;
						}
					}
				}
			}
		}// end of tree route

		this.hasPairMutuallyDep = false;
		for(int i=0; !this.hasPairMutuallyDep && i<numberOfComponents; i++)
			for(int k=i+1; !this.hasPairMutuallyDep && k<numberOfComponents; k++)
				if(componentIntefaceConnections[i][k] && componentIntefaceConnections[k][i])
					this.hasPairMutuallyDep = true;
	}

	/**
	 * Check if two classes distribution are equivalent
	 * @param distr1: first classes distribution
	 * @param distr2: second classes distribution
	 * @return true if both distribution are equivalent, false otherwise
	 * */
	protected boolean equivalentClassesDistribution(int [] distr1, int [] distr2){
		boolean equivalent = true;
		boolean visited [] = new boolean[distr1.length];
		for(int i=0; i<visited.length;i++)
			visited[i]=false;

		for(int i=0; equivalent && i<distr1.length; i++){
			if(!visited[i]){
				visited[i]=true;
				for(int j=i; j<distr1.length; j++){
					if(distr1[i]==distr1[j]){
						if(distr2[i]!=distr2[j]){
							equivalent=false;
						}
						visited[j]=true;
					}
				}
			}
		}
		return equivalent;
	}

	// TODO Do nothing, the conditions are checked by the individual itself
	@Override
	public void setFeasible(boolean feasible) {
		// do nothing
	}

	@Override
	public void setDegreeOfInfeasibility(double degree) {
		// do nothing
	}
}