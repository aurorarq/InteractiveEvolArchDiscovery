package net.sf.jclec.sbse.discovery;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import net.sf.jclec.JCLEC;
import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.util.random.IRandGen;

/**
 * Schema for Species for the discovery problem.
 * 
 * <p>HISTORY:
 * <ul>
 * 	<li>1.0: Creation (January 2013)
 * 	<li>2.0: Refactoring (July 2013)
 * </ul>
 * 
 * @author Aurora Ramirez Quesada
 * @author Jose Raul Romero
 * @author Sebastian Ventura
 * @version 2.0
 * */
public class Schema implements JCLEC {

	//////////////////////////////////////////////////////////////////
	//----------------------------------------------------- Properties
	//////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	private static final long serialVersionUID = 1010839709573061669L;

	/** All terminals */
	protected TerminalNode [] terminals;

	/** All non terminals */
	protected NonTerminalNode [] nonTerminals;

	/** Root symbol name */
	protected String rootSymbol;

	/** Minimum number of components */
	protected int minNumberOfComponents;

	/** Maximum number of components */
	protected int maxNumberOfComponents;

	/** Number of classes */
	protected int numberOfClasses;

	/** Components assigned to each class (e.g. distribution[class]=component) */
	protected int [] distribution;

	/** Terminal symbols map */
	protected transient HashMap<String, TerminalNode> terminalsMap;

	/** Non terminal symbols map */
	protected transient HashMap<String, NonTerminalNode[]> nonTerminalsMap;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor.
	 * */
	public Schema(){
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////

	/**
	 * Set all the terminal symbols.
	 * @param terminalNodes Terminals array.
	 * */
	public void setTerminals(TerminalNode[] terminalNodes) {
		// Set terminal symbols
		this.terminals = terminalNodes;
		// Set terminal symbols map
		setTerminalsMap();
	}
	
	/**
	 * Get all terminal symbols.
	 * @return Terminals array.
	 * */
	public TerminalNode [] getTerminals(){
		return this.terminals;
	}
	
	/**
	 * Set all the non terminal symbols.
	 * @param nonTerminals Non terminal symbols.
	 * */
	public void setNonTerminals(NonTerminalNode[] nonTerminals) {
		// Set non-terminal symbols
		this.nonTerminals = nonTerminals;
		// Set non-terminal symbols map
		setNonTerminalsMap();
	}

	/**
	 * Set the start symbol.
	 * @param rootSymbol Start symbol.
	 * */
	public void setRootSymbol(String rootSymbol) {
		this.rootSymbol = rootSymbol;
	}
	
	/**
	 * Get the root symbol
	 * @return Root symbol
	 * */
	public String getRootSymbol(){
		return this.rootSymbol;
	}

	/**
	 * Get the minimum number of components.
	 * @return The value of iMinNumOfComp.
	 * */
	public int getMinNumOfComp(){
		return this.minNumberOfComponents;
	}

	/**
	 * Set the minimum number of components.
	 * @param minNumberOfComponents The minimum number to be set.
	 * */
	public void setMinNumOfComp(int minNumberOfComponents){
		this.minNumberOfComponents=minNumberOfComponents;
	}

	/**
	 * Get the maximum number of components.
	 * @return The value of iMaxNumOfComp.
	 * */
	public int getMaxNumOfComp(){
		return this.maxNumberOfComponents;
	}

	/**
	 * Set the maximum number of components.
	 * @param maxNumberOfComponents The maximum number to be set.
	 * */
	public void setMaxNumOfComp(int maxNumberOfComponents){
		this.maxNumberOfComponents=maxNumberOfComponents;
	}

	/**
	 * Set the number of classes.
	 * @param numberOfClasses The number of classes
	 * */
	public void setNumOfClasses(int numberOfClasses){
		this.numberOfClasses=numberOfClasses;
	}
	
	/**
	 * Get the number of classes.
	 * @return The number of classes.
	 * */
	public int getNumOfClasses(){
		return this.numberOfClasses;
	}
	
	/**
	 * Check if the given symbol is a terminal symbol.
	 * @param symbol The symbol to be checked.
	 * @return true if the symbol is terminal, false otherwise.
	 * */
	public boolean isTerminal(String symbol) {
		return terminalsMap.containsKey(symbol);
	}

	/**
	 * Get a terminal giving his name.
	 * @param symbol Symbol name.
	 * @return Desired terminal.
	 * */
	public TerminalNode getTerminal(String symbol) {
		return terminalsMap.get(symbol);
	}
	
	/**
	 * Get a non terminal given its name.
	 * @param symbol Symbol name.
	 * @return Desired non terminal.
	 * */
	public NonTerminalNode [] getNonTerminal(String symbol) {
		return nonTerminalsMap.get(symbol);
	}
	
	public int[] getClassesDistribution(){
		return this.distribution;
	}
	
	/**
	 * Create new components model tree
	 * @param numberOfComponents Number of components to be included in the tree
	 * @param randgen The random object
	 * @return A new SyntaxTree containing the components model
	 * */
	public SyntaxTree createSyntaxTree(int numberOfComponents, IRandGen randgen){

		SyntaxTree tree = new SyntaxTree();

		// Generate the random distribution of classes
		createClassesDistribution(numberOfComponents, randgen);

		// Start expanding the tree
		fillSyntaxBranch(tree, this.rootSymbol, numberOfComponents);

		return tree;
	}
	
	/**
	 * Create new components model tree
	 * @param numberOfComp Number of components to be included in the tree
	 * @param oDataset The dataset with class model information
	 * @param randgen The random object
	 * @param distribution The classes distribution
	 * @return A new SyntaxTree containing the components model
	 * */
	public SyntaxTree createSyntaxTree(int numberOfComponents, int[] distribution){

		SyntaxTree tree = new SyntaxTree();
		
		// Set the class distribution
		this.distribution = new int[distribution.length];
		for(int i=0; i<distribution.length; i++)
			this.distribution[i] = distribution[i];
		
		// Start expanding the tree
		fillSyntaxBranch(tree, this.rootSymbol, numberOfComponents);

		return tree;
	}

	/**
	 * Recursive generation of tree branches
	 * @param tree The tree
	 * @param symbol The actual symbol
	 * @param numberOfComp The number of components to generate. For classes symbol, it represent the number of his component.
	 * */
	public void fillSyntaxBranch(SyntaxTree tree, String symbol, int numberOfComp) {
		// Terminal, add node
		if (isTerminal(symbol)) {
			tree.addNode(getTerminal(symbol));
		}

		// Non terminal
		else {
			// Get the element decomposition
			NonTerminalNode nonTerminal = this.nonTerminalsMap.get(symbol)[0]; 

			if (nonTerminal != null) {

				// Add this node
				tree.addNode(nonTerminal);

				// Continue the element decomposition
				int numberOfElements = nonTerminal.arity();
				if(numberOfElements>0){
					for (int i=0; i<numberOfElements; i++)
						fillSyntaxBranch(tree, nonTerminal.getElements()[i], numberOfComp);
				}

				// The non terminal requires a dynamically decomposition
				else{
					// If the symbol is "components", expand the number of components
					if(nonTerminal.getSymbol().equalsIgnoreCase("components")){
						for(int i=0; i<numberOfComp; i++)
							fillSyntaxBranch(tree, "component", i);
					}

					// If the symbol is "classes", add the classes assigned to component "iNumOfComp"
					else if(nonTerminal.getSymbol().equalsIgnoreCase("classes")){
						setClassesInComponent(tree, numberOfComp);
					}

					// If the symbol is "required_interfaces", add the interfaces required by classes of the actual component
					else if (nonTerminal.getSymbol().equalsIgnoreCase("required-interfaces")){
						setRequiredInterfaces(tree, numberOfComp);
					}

					// If the symbol is "provided_interfaces", add the interfaces provided by classes of the actual component
					else if (nonTerminal.getSymbol().equalsIgnoreCase("provided-interfaces")){
						setProvidedInterfaces(tree, numberOfComp);
					}

					// If the symbol is "connectors", generate the required connectors using interfaces information
					else if(nonTerminal.getSymbol().equalsIgnoreCase("connectors")){
						setConnectors(tree, numberOfComp);
					}
				}
			}
		}
	}
	
	/**
	 * Set connector information in the tree.
	 * @param tree The tree.
	 * @param numberOfComponents Number of components in the tree.
	 * */
	public void setConnectors(SyntaxTree tree, int numberOfComponents) {

		int size = tree.size();
		String actualSymbol, comparedSymbol;
		String actualReqClass, actualProvClass, comparedReqClass, comparedProvClass;
		boolean isLastInterface;
		int [] compPos = new int[numberOfComponents];
		int [] reqPos = new int[numberOfComponents];
		int [] provPos = new int[numberOfComponents];

		// Get the positions of component and interface symbols
		locateComponentInterfaces(tree, compPos, reqPos, provPos);

		// For each component
		for(int i=0; i<numberOfComponents; i++){

			// For each required interface in the component
			for(int j=reqPos[i]+1; j<provPos[i]; j++){

				actualSymbol = tree.getNode(j).getSymbol();

				// Check the provided interfaces in the rest of components
				for(int k=0; k<numberOfComponents; k++){
					if(k!=i){
						isLastInterface=false;
						for(int l=provPos[k]+1; !isLastInterface; l++){

							// Check if the component contains provided interfaces (terminal node)
							if(this.terminalsMap.containsKey(tree.getNode(l).getSymbol())){
								comparedSymbol = tree.getNode(l).getSymbol();

								// Get the classes that defines the interfaces and compare it. 
								actualReqClass = actualSymbol.substring(0, actualSymbol.indexOf('_'));
								actualProvClass = actualSymbol.substring(actualSymbol.lastIndexOf('_')+1);
								comparedReqClass = comparedSymbol.substring(0, comparedSymbol.indexOf('_'));
								comparedProvClass = comparedSymbol.substring(comparedSymbol.lastIndexOf('_')+1);

								// Check if the interfaces must be connected
								if(actualReqClass.equalsIgnoreCase(comparedProvClass) && actualProvClass.equalsIgnoreCase(comparedReqClass)){
									tree.addNode(this.nonTerminalsMap.get("connector")[0]);	// connector
									tree.addNode(this.nonTerminalsMap.get("required-interface")[0]);	// required interface
									tree.addNode(this.terminalsMap.get(actualSymbol));
									tree.addNode(this.nonTerminalsMap.get("provided-interface")[0]);	// provided interface
									tree.addNode(this.terminalsMap.get(comparedSymbol));
								}

								// Check the end of the tree
								if(l==size-2 || (k<numberOfComponents-1 && l==compPos[k+1]-1))
									isLastInterface=true;
							}
						//The next symbol is a non-terminal, then the component does not provide interfaces	
						else
							isLastInterface=true;
						}
					}
				}
			}
		}
	}

	
	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////

	/**
	 * Build and set the terminals map.
	 * */
	protected final void setTerminalsMap() {
		this.terminalsMap = new HashMap<String, TerminalNode> ();
		for (TerminalNode termSymbol : this.terminals) {
			this.terminalsMap.put(termSymbol.getSymbol(), termSymbol);
		}
	}

	/**
	 * Build and set the non terminals map.
	 * */
	protected final void setNonTerminalsMap() {
		// Used to classify symbols
		HashMap<String, List<NonTerminalNode>> auxMap = 
				new HashMap<String, List<NonTerminalNode>> ();
		// Classify non-term symbols
		for (NonTerminalNode nonTermSymbol : this.nonTerminals) {
			String nonTermSymbolName = nonTermSymbol.getSymbol();
			if (auxMap.containsKey(nonTermSymbolName)) {
				auxMap.get(nonTermSymbolName).add(nonTermSymbol);
			}
			else {
				ArrayList<NonTerminalNode> list = 
						new ArrayList<NonTerminalNode>();
				list.add(nonTermSymbol);
				auxMap.put(nonTermSymbolName, list);
			}
		}		
		// Create non-term symbols map
		this.nonTerminalsMap = new HashMap<String, NonTerminalNode[]> ();
		for (String nonTermName : auxMap.keySet()) {
			// Get symbols list
			List<NonTerminalNode> list = auxMap.get(nonTermName);
			// Convert list to array
			NonTerminalNode [] array = 
					list.toArray(new NonTerminalNode[list.size()]);
			// Put array in non terminals map
			this.nonTerminalsMap.put(nonTermName, array);
		}
	}

	/////////////////////////////////////////////////////////////////
	// ---------------------------------------------- Private methods
	/////////////////////////////////////////////////////////////////

	/**
	 * Generate a random distribution of classes
	 * @param iNumComp The number of components
	 * @param rand The random object
	 * */
	protected void createClassesDistribution(int numberOfComponents, IRandGen rand){

		// Set classes
		ArrayList<Integer> rgoClasses = new ArrayList<Integer>(this.numberOfClasses);
		for(int i=0; i<this.numberOfClasses; i++){
			rgoClasses.add(i);
		}

		// Initialize components distribution
		this.distribution = new int[this.numberOfClasses];
		int i, index;
		for(i=0; i<this.numberOfClasses; i++)
			this.distribution[i] = -1;

		// First, assign one class to each component, without repeating classes
		for(i=0; i<numberOfComponents; i++){
			index = rand.choose(0, rgoClasses.size());
			this.distribution[rgoClasses.get(index)] = i;
			rgoClasses.remove(index);
		}

		// Then, assign the rest of classes
		for(i=0; i<this.numberOfClasses; i++){
			if(this.distribution[i] == -1){
				index = rand.choose(0, numberOfComponents);
				this.distribution[i] = index;
			}
		}
	}

	/**
	 * Add the nodes that represent the classes belonging to a component
	 * @param tree The model tree
	 * @param component The actual component
	 * */
	private void setClassesInComponent(SyntaxTree tree, int component) {
		for(int i=0; i<this.numberOfClasses; i++){
			if(this.distribution[i]==component){
				tree.addNode(this.terminals[i]);
			}
		}
	}

	/**
	 * Add the nodes that represent the component required interfaces
	 * @param tree The model tree
	 * @param component The actual component
	 * */
	private void setRequiredInterfaces(SyntaxTree tree, int component) {
		int numberOffInterfaces = this.terminals.length-this.numberOfClasses;
		for(int i=0; i<numberOffInterfaces; i++){
			for(int j=0; j<this.numberOfClasses; j++){
				for(int k=0; k<this.numberOfClasses; k++){
					// Check relations between classes from different components
					if(this.distribution[j]==component && 
							this.distribution[j]!=this.distribution[k] &&
							this.terminals[i+this.numberOfClasses].getSymbol().equalsIgnoreCase(this.terminals[j].getSymbol()+"_req_"+this.terminals[k])){
						tree.addNode(this.terminals[i+this.numberOfClasses]);
					}
				}
			}
		}
	}

	/**
	 * Add the nodes that represent the component provided interfaces
	 * @param tree The model tree
	 * @param iComp The actual component
	 * */
	private void setProvidedInterfaces(SyntaxTree tree, int component) {
		int numberOfInterfaces = this.terminals.length-this.numberOfClasses;
		for(int i=0; i<numberOfInterfaces; i++){
			for(int j=0; j<this.numberOfClasses; j++){
				for(int k=0; k<this.numberOfClasses; k++){
					// Check relations between classes from different components
					if(this.distribution[j]==component && 
							this.distribution[j]!=this.distribution[k] &&
							this.terminals[i+this.numberOfClasses].getSymbol().equalsIgnoreCase(this.terminals[j].getSymbol()+"_prov_"+this.terminals[k])){
						tree.addNode(this.terminals[i+this.numberOfClasses]);
					}
				}
			}
		}
	}
	
	/**
	 * Search for component and interfaces symbols and 
	 * save the positions in the respective array.
	 * @param tree The tree
	 * @param compPos The array for component positions
	 * @param reqPos The array for required interfaces positions
	 * @param provPos The array for provided interfaces positions
	 * */
	private void locateComponentInterfaces(SyntaxTree tree, int [] compPos, int [] reqPos, int [] provPos){
		int size = tree.size();
		int actualComp=-1;
		String symbol;
		for(int i=0; i<size; i++){
			symbol = tree.getNode(i).getSymbol();
			if(symbol.equalsIgnoreCase("component")){
				actualComp++;
				compPos[actualComp] = i;
			}
			else if(symbol.equalsIgnoreCase("required-interfaces"))
				reqPos[actualComp] = i;
			else if(symbol.equalsIgnoreCase("provided-interfaces"))
				provPos[actualComp] = i;
		}
	}
}