package net.sf.jclec.sbse.discovery;

import java.util.ArrayList;
import java.util.List;

import es.uco.kdis.datapro.dataset.Dataset;
import es.uco.kdis.datapro.dataset.column.MultiIntegerColumn;
import es.uco.kdis.datapro.datatypes.MultiIntegerValue;
import es.uco.kdis.datapro.datatypes.InvalidValue;
import net.sf.jclec.ISpecies;
import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.SyntaxTreeIndividual;

/**
 * Species for the discovery problem.
 * 
 * <p>HISTORY:
 * <ul>
 * 	<li>1.0: Creation (January 2013)
 * 	<li>2.0: Refactoring. Multicolumn (CSV) dataset (May 2013)
 *  <li>3.0: Refactoring. Change to abstract class. The creation
 *  of individuals is specific for the problem formulation  (December 2013)
 * </ul>
 * 
 * @author Aurora Ramirez Quesada
 * @author Jose Raul Romero
 * @author Sebastian Ventura
 * @version 3.0
 * */
public abstract class Species implements ISpecies{

	//////////////////////////////////////////////////////////////////
	//----------------------------------------------------- Properties
	//////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	private static final long serialVersionUID = 524943799721320209L;

	/** The tree schema */
	protected Schema schema;

	/** Dataset storing information about relationships */
	protected Dataset dataset;

	//////////////////////////////////////////////////////////////////
	//--------------------------------------------------- Constructors
	//////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 * */
	public Species(){
		super();
	}

	//////////////////////////////////////////////////////////////////
	//------------------------------------------------- Public methods
	//////////////////////////////////////////////////////////////////

	/**
	 * Create new individual.
	 * @param genotype: Individual genotype.
	 * @param id: Individual id
	 * @return A new individual with the given genotype.
	 * */
	public abstract SyntaxTreeIndividual createIndividual(SyntaxTree genotype);

	/**
	 * Set the model constraints
	 * @param minNumOfComp Minimum number of components.
	 * @param maxNumOfComp Maximum number of components.
	 * */
	public void setConstraints(int minNumOfComp, int maxNumOfComp){

		// Create and configure the genotype schema
		this.schema = new Schema();
		this.schema.setRootSymbol("components-model");
		this.schema.setTerminals(this.generateTerminalSymbols());
		this.schema.setNonTerminals(this.generateNonTerminalSymbols());
		this.schema.setMinNumOfComp(minNumOfComp);
		this.schema.setMaxNumOfComp(maxNumOfComp);
		this.schema.setNumOfClasses(this.dataset.getColumns().size());
	}

	/**
	 * Set the dataset that stores 
	 * the information of the relationships
	 * @param dataset The dataset
	 * */
	public void setDataset(Dataset dataset) {
		this.dataset = dataset;
	}

	/**
	 * Get the dataset.
	 * @return The dataset object.
	 * */
	public Dataset getDataset(){
		return this.dataset;
	}
	
	/**
	 * Get genotype schema
	 * @return Genotype schema
	 * */
	public Schema getGenotypeSchema() {
		return schema;
	}
	
	//////////////////////////////////////////////////////////////////
	//---------------------------------------------- Protected methods
	//////////////////////////////////////////////////////////////////

	/**
	 * Generate terminal symbols using 
	 * dataset attributes names.
	 * @return Array of terminal symbols.
	 * */

	protected TerminalNode [] generateTerminalSymbols(){

		int numCols = this.dataset.getColumns().size();
		MultiIntegerColumn column;
		List<Object> values;
		ArrayList<TerminalNode> terminalsList = new ArrayList<TerminalNode>();
		Object oRelations_ij;
		Object oRelations_ji;
		MultiIntegerValue relations_ij;
		MultiIntegerValue relations_ji;
		
		boolean isCandidateReq, isCandidateProv;

		// Set the class names as terminal nodes
		for(int i=0; i<numCols; i++){
			column = (MultiIntegerColumn) this.dataset.getColumn(i);
			terminalsList.add(new TerminalNode(column.getName()));
		}

		// Set the possible interfaces as terminal nodes
		int numValues;
		int navValue_ij, navValue_ji;

		// For each column (class i)
		for(int i=0; i<numCols; i++){
			column = (MultiIntegerColumn) this.dataset.getColumn(i);
			values = column.getValues();
			numValues = values.size();

			// For each instance (class j)
			for(int j=0; j<numValues; j++){

				oRelations_ij = values.get(j);
				oRelations_ji = ((MultiIntegerColumn)this.dataset.getColumn(j)).getValues().get(i);

				// Not an invalid value (at least one relation -> 2 values in the array)
				if(!(oRelations_ij instanceof InvalidValue)){

					relations_ij = (MultiIntegerValue)oRelations_ij;
					relations_ji = (MultiIntegerValue)oRelations_ji;
					
					isCandidateReq = false;
					isCandidateProv = false;

					// Check the navigability of each relation between class i and j
					for(int k=1; (isCandidateReq==false || isCandidateProv==false) && k<relations_ij.getSize(); k+=2){
						
						navValue_ij = relations_ij.getValue(k);
						navValue_ji = relations_ji.getValue(k);

						// Exist a unidirectional relation (class i -> class j), so class i needs class j
						if(!isCandidateReq && navValue_ij == 0 && navValue_ji == 1){
							terminalsList.add(new TerminalNode(column.getName() + "_req_" + this.dataset.getColumn(j).getName()));
							isCandidateReq=true;
						}

						// Exist a unidirectional relation (class i <- class j), so class i provides class j
						if (!isCandidateProv && navValue_ij == 1 && navValue_ji == 0){
							terminalsList.add(new TerminalNode(column.getName() + "_prov_" + this.dataset.getColumn(j).getName()));
							isCandidateProv=true;
						}
					}
				}
			}
		}

		TerminalNode [] arrayOfTerminals = new TerminalNode[terminalsList.size()];
		terminalsList.toArray(arrayOfTerminals);
		return arrayOfTerminals;
	}

	/**
	 * Generate non terminal symbols and their productions.
	 * @return Array of non terminal symbols.
	 * */
	protected NonTerminalNode [] generateNonTerminalSymbols(){

		// Set non terminal symbols and their decomposition symbols
		NonTerminalNode [] nonTerminals = new NonTerminalNode[10];

		// <components-model> := <components> U <conectors>
		nonTerminals[0] = new NonTerminalNode("components-model", new String [] {"components", "connectors"});

		// <components> := <component> <component>+ (created later)
		nonTerminals[1] = new NonTerminalNode("components", null);

		// <connectors> := <connector>+ (created later)
		nonTerminals[2] = new NonTerminalNode("connectors", null);

		// <component> := <classes> U <requiered-interfaces> U <provided-interfaces>
		nonTerminals[3] = new NonTerminalNode("component", new String [] {"classes", "required-interfaces", "provided-interfaces"});

		// <connector> := <requiered-interface> U <provided-interface>
		nonTerminals[4] = new NonTerminalNode("connector", new String [] {"required-interface", "provided-interface"});

		// <classes> := <class>+ (created later)
		nonTerminals[5] = new NonTerminalNode("classes", null);

		// <requiered-interfaces> := <interface>+ (created later)
		nonTerminals[6] = new NonTerminalNode("required-interfaces", null);

		// <provided-interface> := <interface>+ (created later)
		nonTerminals[7] = new NonTerminalNode("provided-interfaces", null);

		// <requiered-interface> := <interface> (created later)
		nonTerminals[8] = new NonTerminalNode("required-interface", null);

		// <provided-interface> := <interface> (created later)
		nonTerminals[9] = new NonTerminalNode("provided-interface", null);

		return nonTerminals;
	}
}