package net.sf.jclec.sbse.discovery;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.configuration.Configuration;

import net.sf.jclec.IConfigure;
import net.sf.jclec.IIndividual;
import net.sf.jclec.ISpecies;
import net.sf.jclec.algorithm.PopulationAlgorithm;
import net.sf.jclec.base.AbstractMutator;
import net.sf.jclec.sbse.discovery.mut.AbstractCmpMutator;

/**
 * Base mutator for 'Classes to Components' (Cl2Cmp) problem.
 * 
 * @author Aurora Ramirez Quesada
 * @author Jose Raul Romero
 * @author Sebastian Ventura
 * 
 * @version 2.1
 * History:
 * <ul>
 * 	<li>1.0: Creation (January 2013)
 * 	<li>2.0: Refactoring, probabilistic procedure for invalids added (June 2013)
 *  <li>2.1: Refactoring, removing evaluator (December 2013)
 * </ul>
 * */
public class Mutator extends AbstractMutator implements IConfigure{

	//////////////////////////////////////////////////////////////////
	//----------------------------------------------------- Properties
	//////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	private static final long serialVersionUID = 8492411514101534424L;

	/** Mutation operations */
	protected List<AbstractCmpMutator> mutators;

	/** Individual species */
	protected transient Species species;

	/** Individuals schema */
	protected transient Schema schema;
	
	/** Mutator roulette */
	protected transient double [] roulette;

	/** Save number of new individuals */
	protected transient List<Integer> offsprings;

	/** New offsprings generated */
	protected int newOffsprings;

	/** Probability for invalids acceptance */
	protected double probInvalids;

	/** Max of generations */
	protected int maxGenerations;

	/** Max of attempts in mutation */
	protected int maxOfAttempts;

	/** Consider the probability of invalid acceptance */
	protected boolean probAcceptanceInvalids;

	//////////////////////////////////////////////////////////////////
	//------------------------------------------------- Constructors
	//////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 * */
	public Mutator(){
		super();
		this.mutators = new ArrayList<AbstractCmpMutator>();
		this.offsprings = new ArrayList<Integer>();
	}

	//////////////////////////////////////////////////////////////////
	//----------------------------------------------- Override methods
	//////////////////////////////////////////////////////////////////

	@Override
	@SuppressWarnings("unchecked")
	public void configure(Configuration settings){

		// Get mutation operations
		String mutatorClassnames [] = 
				settings.getStringArray("mutator[@type]");
		String weights [] = settings.getStringArray("mutator[@weight]");
		String random [] = settings.getStringArray("mutator[@random]");

		// Configure and contextualize each mutator
		for(int i=0; i<mutatorClassnames.length; i++){
			Class<? extends AbstractCmpMutator> mutatorClass;
			try {
				mutatorClass = (Class<? extends AbstractCmpMutator>) Class.forName(mutatorClassnames[i]);
				this.mutators.add(mutatorClass.newInstance());
				this.mutators.get(i).contextualize(this.context);
				this.mutators.get(i).setWeight(Double.parseDouble(weights[i]));
				this.mutators.get(i).setRandom(Boolean.parseBoolean(random[i]));
			} catch (ClassNotFoundException e) {
				System.err.println("Class " + mutatorClassnames[i] + " not found.");
				e.printStackTrace();
				System.exit(1);
			}catch (Exception e) {
				e.printStackTrace();
				System.exit(1);
			}
		}

		// Get max of attempts
		this.maxOfAttempts = settings.getInt("max-of-attempts", 10);
		this.probAcceptanceInvalids = settings.getBoolean("[@probability-invalids]", false);

		// Check probabilities
		double sumWeight = 0.0;
		for(int i=0; i<weights.length; i++){
			sumWeight += this.mutators.get(i).getWeight();
		}
		if((1.0-sumWeight)>0.000000000001){//!=1.0){
			System.err.println("The sum of mutator weights must be 1");
			System.exit(1);
		}

		// Contextualize species and evaluator
		specificContextualize();

		// Allocate space for roulette
		this.roulette = new double[this.mutators.size()];
		this.maxGenerations = ((PopulationAlgorithm)this.context).getMaxOfGenerations();
	}

	@Override
	public List<IIndividual> mutate(List<IIndividual> parents) {

		// Reset offspring counter
		this.newOffsprings=0;

		// Sets p list to actual parents
		this.parentsBuffer = parents;

		// Create a new list to put sons in it
		this.sonsBuffer = new ArrayList<IIndividual> ();

		// Update probability
		this.probInvalids = ((double)this.maxGenerations-((PopulationAlgorithm)this.context).getGeneration())/(this.maxGenerations);

		// Mutate fertile individuals
		for(this.parentsCounter=0; this.parentsCounter<this.parentsBuffer.size(); this.parentsCounter++){
			prepareMutation();
			mutateNext();
		}
		this.offsprings.add(new Integer(this.newOffsprings));

		// Returns sons list
		return sonsBuffer;
	}

	@Override
	public void prepareMutation(){

		Individual ind = (Individual)this.parentsBuffer.get(this.parentsCounter);
		double acc = 0.0;

		// Create roulette
		for(int i=0; i<this.roulette.length; i++){
			if(this.mutators.get(i).isApplicable(ind)){
				acc += this.mutators.get(i).getWeight();
			}
			this.roulette[i] = acc;
		}

		// Normalize
		if(acc!=0){
			for(int i=0; i<this.roulette.length; i++){
				this.roulette[i] /= acc;
			}
		}
	}

	@Override
	protected void mutateNext() {

		// Individual to be mutated
		IIndividual ind = this.parentsBuffer.get(this.parentsCounter);
		IIndividual mutInd = null;
		int numOfAttempts = 0;
		int randomIndex=-1;				// The random mutator index
		double randomValue;			
		boolean isNewValidIndividual = false;

		// Try to generate a valid individual. If the mutation is performed 10 times
		// without exit, return the parent
		int numMutators = this.roulette.length;

		// Check if the roulette is not empty (at least one mutator is applicable) 
		if(this.roulette[numMutators-1] != 0.0){
			do{
				randomIndex = -1;
				randomValue = this.randgen.raw();
				// Selects mutator using the roulette 
				for (int i=0; i<this.roulette.length && randomIndex==-1; i++) {
					if (randomValue <= this.roulette[i]) {
						randomIndex = i;
					}
				}
				mutInd = this.mutators.get(randomIndex).mutateIndividual((Individual)ind, this.randgen);
				isNewValidIndividual = ((Individual)mutInd).isFeasible();
				numOfAttempts++;
			}while(numOfAttempts<=this.maxOfAttempts && !isNewValidIndividual);

			// Valid individual, add to sons buffer
			if(isNewValidIndividual){
				this.sonsBuffer.add(mutInd);
				this.newOffsprings++;
			}

			// Invalids offsprings are allowed with a certain probability
			else{
				randomValue = this.randgen.raw();
				// Add invalid offspring
				if(randomValue <= this.probInvalids){
					this.sonsBuffer.add(mutInd);
					this.newOffsprings++;
				}
				// Add parent
				else{
					this.sonsBuffer.add(ind);
				}
			}
		}
		else // Non applicable mutator: Return parent
			this.sonsBuffer.add(ind);
	}

	//////////////////////////////////////////////////////////////////
	//------------------------------------------------- Public methods
	//////////////////////////////////////////////////////////////////

	/**
	 * Get the mutators
	 * @return the mutator list
	 * */
	public List<AbstractCmpMutator> getMutators(){
		return this.mutators;
	}

	/**
	 * Get the evolution in the number of offsprings
	 * @return the offsprings list
	 * */
	public List<Integer> getOffspringEvolution(){
		return this.offsprings;
	}

	/**
	 * Get the number of actual offsprings
	 * @return number of new offsprings generated
	 * */
	public int getActualOffspring(){
		return this.newOffsprings;
	}

	//////////////////////////////////////////////////////////////////
	//------------------------------------------------ Private methods
	//////////////////////////////////////////////////////////////////

	/**
	 * Contextualize species and evaluator
	 * */
	private void specificContextualize(){
		// Set species from context
		ISpecies species = this.context.getSpecies();
		if (species instanceof Species) {
			// Type conversion 
			this.species = (Species) species;
			// Sets genotype schema
			this.schema = ((Species) species).getGenotypeSchema();
		}
		else {
			throw new IllegalStateException("Invalid species in context");
		}
	}
}