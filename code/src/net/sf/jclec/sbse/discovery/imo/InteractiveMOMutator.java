package net.sf.jclec.sbse.discovery.imo;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.configuration.Configuration;

import net.sf.jclec.IConfigure;
import net.sf.jclec.IIndividual;
import net.sf.jclec.ISpecies;
import net.sf.jclec.base.AbstractMutator;
import net.sf.jclec.mo.strategy.MOStrategyContext;
import net.sf.jclec.sbse.discovery.Individual;
import net.sf.jclec.sbse.discovery.Schema;
import net.sf.jclec.sbse.discovery.Species;
import net.sf.jclec.sbse.discovery.imo.mut.AbstractComponentMutator;

/**
 * Mutator for the interactive discovery of software
 * architectures problem.
 * 
 * <p>HISTORY:
 * <ul>
 * 	<li>1.0: Creation (April 2015)
 * </ul>
 * 
 * @author Aurora Ramirez
 * @author Jose Raul Romero
 * @author Sebastian Ventura
 * @version 1.0
 * */
public class InteractiveMOMutator extends AbstractMutator implements IConfigure{

	//////////////////////////////////////////////////////////////////
	//----------------------------------------------------- Properties
	//////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	private static final long serialVersionUID = 8492411514101534424L;

	/** Mutation operations */
	protected List<AbstractComponentMutator> mutators;

	/** Individual species */
	protected transient Species species;

	/** Individuals schema */
	protected transient Schema schema;
	
	/** Mutator roulette */
	protected transient double [] roulette;

	/** Save number of new individuals */
	//protected transient List<Integer> offsprings;

	/** New offspring generated */
	protected int newOffspring;

	/** Probability for invalids acceptance */
	protected double probInvalids;

	/** Max of generations */
	protected int maxGenerations;

	/** Max of attempts in mutation */
	protected int maxOfAttempts;

	/** Consider the probability of invalid acceptance */
	protected boolean probAcceptanceInvalids;

	//////////////////////////////////////////////////////////////////
	//------------------------------------------------- Constructors
	//////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 * */
	public InteractiveMOMutator(){
		super();
		this.mutators = new ArrayList<AbstractComponentMutator>();
		//this.offsprings = new ArrayList<Integer>();
	}

	//////////////////////////////////////////////////////////////////
	//----------------------------------------------- Override methods
	//////////////////////////////////////////////////////////////////

	@Override
	@SuppressWarnings("unchecked")
	public void configure(Configuration settings){

		// Get mutation operations
		String mutatorClassnames [] = 
				settings.getStringArray("mutator[@type]");
		String weights [] = settings.getStringArray("mutator[@weight]");
		String random [] = settings.getStringArray("mutator[@random]");

		// Configure and contextualize each mutator
		for(int i=0; i<mutatorClassnames.length; i++){
			Class<? extends AbstractComponentMutator> mutatorClass;
			try {
				mutatorClass = (Class<? extends AbstractComponentMutator>) Class.forName(mutatorClassnames[i]);
				this.mutators.add(mutatorClass.newInstance());
				this.mutators.get(i).setWeight(Double.parseDouble(weights[i]));
				this.mutators.get(i).setRandom(Boolean.parseBoolean(random[i]));
			} catch (ClassNotFoundException e) {
				System.err.println("Class " + mutatorClassnames[i] + " not found.");
				e.printStackTrace();
				System.exit(1);
			}catch (Exception e) {
				e.printStackTrace();
				System.exit(1);
			}
		}

		// Get max of attempts
		this.maxOfAttempts = settings.getInt("[@max-of-attempts]", 10);
		this.probAcceptanceInvalids = settings.getBoolean("[@probability-invalids]", false);

		// Check probabilities
		double sumWeight = 0.0;
		for(int i=0; i<weights.length; i++){
			sumWeight += this.mutators.get(i).getWeight();
		}
		if((1.0-sumWeight)>0.000000000001){//!=1.0){
			System.err.println("The sum of mutator weights must be 1");
			System.exit(1);
		}

		// Allocate space for roulette
		this.roulette = new double[this.mutators.size()];
		
	}

	@Override
	public List<IIndividual> mutate(List<IIndividual> parents) {

		//System.out.println("GENERATION: " + this.context.getGeneration());
		
		// Reset offspring counter
		this.newOffspring=0;

		// Sets p list to actual parents
		this.parentsBuffer = parents;

		// Create a new list to put sons in it
		this.sonsBuffer = new ArrayList<IIndividual> ();

		// Update probability
		this.probInvalids = ((double)this.maxGenerations-((MOStrategyContext)this.context).getGeneration())/(this.maxGenerations);

		// Mutate fertile individuals
		for(this.parentsCounter=0; this.parentsCounter<this.parentsBuffer.size(); this.parentsCounter++){
			prepareMutation();
			mutateNext();
		}
		//this.offsprings.add(new Integer(this.newOffspring));

		// Returns sons list
		return sonsBuffer;
	}

	@Override
	public void prepareMutation(){

		InteractiveMOIndividual ind = (InteractiveMOIndividual)this.parentsBuffer.get(this.parentsCounter);
		double acc = 0.0;

		// Create roulette
		for(int i=0; i<this.roulette.length; i++){
			if(this.mutators.get(i).isApplicable(ind)){
				acc += this.mutators.get(i).getWeight();
			}
			this.roulette[i] = acc;
		}

		// Normalize
		if(acc!=0){
			for(int i=0; i<this.roulette.length; i++){
				this.roulette[i] /= acc;
			}
		}
	}

	@Override
	protected void mutateNext() {

		// Individual to be mutated
		InteractiveMOIndividual ind = (InteractiveMOIndividual)this.parentsBuffer.get(this.parentsCounter);
		InteractiveMOIndividual mutInd = null;
		int numOfAttempts = 0;
		int randomIndex=-1;				// The random mutator index
		double randomValue;			
		boolean isNewValidIndividual = false;

		// Try to generate a valid individual. If the mutation is performed 10 times
		// without exit, return the parent
		int numMutators = this.roulette.length;

		// Check if the roulette is not empty (at least one mutator is applicable) 
		if(this.roulette[numMutators-1] != 0.0){
			do{
				randomIndex = -1;
				randomValue = this.randgen.raw();
				// Selects mutator using the roulette 
				for (int i=0; i<this.roulette.length && randomIndex==-1; i++) {
					if (randomValue <= this.roulette[i]) {
						randomIndex = i;
					}
				}
				
				mutInd = (InteractiveMOIndividual)this.mutators.get(randomIndex).mutateIndividual(ind, this.randgen);
				isNewValidIndividual = ((Individual)mutInd).isFeasible();
				numOfAttempts++;
			}while(numOfAttempts<=this.maxOfAttempts && !isNewValidIndividual);

			////////////////////////////////////////
			/*if(mutInd.getNumberOfComponents()==8){
				System.out.println("\nMUTATOR: " + this.mutators.get(randomIndex).getClass().getName());
				//System.out.println("PARENT: " + ind.getGenotype());
				System.out.println("SON: " + mutInd.getGenotype());
			}*/
			////////////////////////////////////////
			
			// Valid individual, add to sons buffer
			if(isNewValidIndividual){
				this.sonsBuffer.add(mutInd);
				this.newOffspring++;
			}

			// Invalid offspring are allowed with a certain probability
			else{
				randomValue = this.randgen.raw();
				// Add invalid offspring
				if(randomValue <= this.probInvalids){
					this.sonsBuffer.add(mutInd);
					this.newOffspring++;
				}
				// Add parent
				else{
					IIndividual copy = ind.copy();
					copy.setFitness(null);
					this.sonsBuffer.add(copy);
				}
			}
		}
		else{ // Non applicable mutator: Return parent
			IIndividual copy = ind.copy();
			copy.setFitness(null);
			this.sonsBuffer.add(copy);
		}
	}

	//////////////////////////////////////////////////////////////////
	//------------------------------------------------- Public methods
	//////////////////////////////////////////////////////////////////

	/**
	 * Get the mutators
	 * @return the mutator list
	 * */
	public List<AbstractComponentMutator> getMutators(){
		return this.mutators;
	}

	/**
	 * Get the evolution in the number of offsprings
	 * @return the offsprings list
	 * */
/*	public List<Integer> getOffspringEvolution(){
		return this.offsprings;
	}*/

	/**
	 * Get the number of actual offsprings
	 * @return number of new offsprings generated
	 * */
	public int getNumberNewOffspring(){
		return this.newOffspring;
	}

	//////////////////////////////////////////////////////////////////
	//------------------------------------------------ Private methods
	//////////////////////////////////////////////////////////////////

	/**
	 * Contextualize species and evaluator
	 * */
	public void specificContextualize(int maxOfGenerations){
		// Set species from context
		ISpecies species = this.context.getSpecies();
		if (species instanceof Species) {
			// Type conversion 
			this.species = (Species) species;
			// Sets genotype schema
			this.schema = ((Species) species).getGenotypeSchema();
		}
		else {
			throw new IllegalStateException("Invalid species in context");
		}
		// Contextualize subprocesses
		int size = mutators.size();
		for(int i=0; i<size; i++){
			this.mutators.get(i).contextualize(this.context);
		}
		
		// Get max of generations
		this.maxGenerations = maxOfGenerations;
	}
}